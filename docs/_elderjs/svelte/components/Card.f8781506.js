import { w as get_current_component, x as listen, y as bubble, z as create_slot, e as element, c as claim_element, a as children, d as detach_dev, f as add_location, i as insert_dev, A as update_slot, o as transition_in, p as transition_out, h as dispatch_dev, B as assign, C as space, D as claim_space, E as set_attributes, F as toggle_class, g as append_dev, G as action_destroyer, H as group_outros, I as check_outros, J as get_spread_update, K as compute_rest_props, v as validate_slots, L as compute_slots, M as exclude_internal_props, S as SvelteComponentDev, r as init, u as safe_not_equal } from '../index-50e9cdeb.js';

// Copied from https://github.com/AlexxNB/svelte-chota/blob/master/cmp/utils.js

function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]'
}
function getEventsAction() {
    const component = get_current_component();
    return node => {
      const events = Object.keys(component.$$.callbacks);
      const listeners = [];

      events.forEach(
          event => listeners.push(
              listen(node, event, e =>  bubble(component, e))
            )
        );

      return {
        destroy: () => {
            listeners.forEach(
                listener => listener()
            );
        }
      }
    };
}

/* src/components/Card.svelte generated by Svelte v3.38.3 */
const file = "src/components/Card.svelte";
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});
const get_thumb_slot_changes = dirty => ({});
const get_thumb_slot_context = ctx => ({});

// (7:0) {#if $$slots.header}
function create_if_block_2(ctx) {
	let div;
	let current;
	const thumb_slot_template = /*#slots*/ ctx[4].thumb;
	const thumb_slot = create_slot(thumb_slot_template, ctx, /*$$scope*/ ctx[3], get_thumb_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			if (thumb_slot) thumb_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			if (thumb_slot) thumb_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file, 7, 2, 175);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (thumb_slot) {
				thumb_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (thumb_slot) {
				if (thumb_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot(thumb_slot, thumb_slot_template, ctx, /*$$scope*/ ctx[3], !current ? -1 : dirty, get_thumb_slot_changes, get_thumb_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(thumb_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(thumb_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (thumb_slot) thumb_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(7:0) {#if $$slots.header}",
		ctx
	});

	return block;
}

// (12:0) {#if $$slots.thumb}
function create_if_block_1(ctx) {
	let header;
	let current;
	const header_slot_template = /*#slots*/ ctx[4].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[3], get_header_slot_context);

	const block = {
		c: function create() {
			header = element("header");
			if (header_slot) header_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			header = claim_element(nodes, "HEADER", {});
			var header_nodes = children(header);
			if (header_slot) header_slot.l(header_nodes);
			header_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(header, file, 12, 2, 249);
		},
		m: function mount(target, anchor) {
			insert_dev(target, header, anchor);

			if (header_slot) {
				header_slot.m(header, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[3], !current ? -1 : dirty, get_header_slot_changes, get_header_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(header);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(12:0) {#if $$slots.thumb}",
		ctx
	});

	return block;
}

// (18:0) {#if $$slots.footer}
function create_if_block(ctx) {
	let footer;
	let current;
	const footer_slot_template = /*#slots*/ ctx[4].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[3], get_footer_slot_context);

	const block = {
		c: function create() {
			footer = element("footer");
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			footer = claim_element(nodes, "FOOTER", {});
			var footer_nodes = children(footer);
			if (footer_slot) footer_slot.l(footer_nodes);
			footer_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(footer, file, 18, 2, 349);
		},
		m: function mount(target, anchor) {
			insert_dev(target, footer, anchor);

			if (footer_slot) {
				footer_slot.m(footer, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (footer_slot) {
				if (footer_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[3], !current ? -1 : dirty, get_footer_slot_changes, get_footer_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(footer);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(18:0) {#if $$slots.footer}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let events_action;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*$$slots*/ ctx[2].header && create_if_block_2(ctx);
	let if_block1 = /*$$slots*/ ctx[2].thumb && create_if_block_1(ctx);
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let if_block2 = /*$$slots*/ ctx[2].footer && create_if_block(ctx);
	let div_levels = [/*$$restProps*/ ctx[1]];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block2) if_block2.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t0 = claim_space(div_nodes);
			if (if_block1) if_block1.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (default_slot) default_slot.l(div_nodes);
			t2 = claim_space(div_nodes);
			if (if_block2) if_block2.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(div, div_data);
			toggle_class(div, "card", 1);
			add_location(div, file, 5, 0, 103);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t2);
			if (if_block2) if_block2.m(div, null);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(events_action = /*events*/ ctx[0].call(null, div));
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*$$slots*/ ctx[2].header) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$$slots*/ 4) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*$$slots*/ ctx[2].thumb) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$$slots*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], !current ? -1 : dirty, null, null);
				}
			}

			if (/*$$slots*/ ctx[2].footer) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*$$slots*/ 4) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]]));
			toggle_class(div, "card", 1);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block2) if_block2.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Card", slots, ['thumb','header','default','footer']);
	const $$slots = compute_slots(slots);
	const events = getEventsAction();

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({ getEventsAction, events });
	return [events, $$restProps, $$slots, $$scope, slots];
}

class Card extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Card",
			options,
			id: create_fragment.name
		});
	}
}

export default Card;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2FyZC5mODc4MTUwNi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvdXRpbHMuanMiLCIuLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9DYXJkLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vQWxleHhOQi9zdmVsdGUtY2hvdGEvYmxvYi9tYXN0ZXIvY21wL3V0aWxzLmpzXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xufVxuXG5cbmltcG9ydCB7YnViYmxlLCBsaXN0ZW4sZ2V0X2N1cnJlbnRfY29tcG9uZW50fSBmcm9tICdzdmVsdGUvaW50ZXJuYWwnO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV2ZW50c0FjdGlvbigpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBnZXRfY3VycmVudF9jb21wb25lbnQoKTtcbiAgICByZXR1cm4gbm9kZSA9PiB7XG4gICAgICBjb25zdCBldmVudHMgPSBPYmplY3Qua2V5cyhjb21wb25lbnQuJCQuY2FsbGJhY2tzKTtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuXG4gICAgICBldmVudHMuZm9yRWFjaChcbiAgICAgICAgICBldmVudCA9PiBsaXN0ZW5lcnMucHVzaChcbiAgICAgICAgICAgICAgbGlzdGVuKG5vZGUsIGV2ZW50LCBlID0+ICBidWJibGUoY29tcG9uZW50LCBlKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPT4gbGlzdGVuZXIoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG59IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQge2dldEV2ZW50c0FjdGlvbn0gZnJvbSAnLi91dGlscyc7XG4gICAgY29uc3QgZXZlbnRzID0gZ2V0RXZlbnRzQWN0aW9uKCk7XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzczpjYXJkPXsxfSB1c2U6ZXZlbnRzIHsuLi4kJHJlc3RQcm9wc30+XG57I2lmICQkc2xvdHMuaGVhZGVyfVxuICA8ZGl2PlxuICAgIDxzbG90IG5hbWU9XCJ0aHVtYlwiPjwvc2xvdD5cbiAgPC9kaXY+XG57L2lmfVxueyNpZiAkJHNsb3RzLnRodW1ifVxuICA8aGVhZGVyPlxuICAgIDxzbG90IG5hbWU9XCJoZWFkZXJcIj48L3Nsb3Q+XG4gIDwvaGVhZGVyPlxuey9pZn1cbiAgICA8c2xvdD48L3Nsb3Q+XG57I2lmICQkc2xvdHMuZm9vdGVyfVxuICA8Zm9vdGVyPlxuICAgIDxzbG90IG5hbWU9XCJmb290ZXJcIj48L3Nsb3Q+XG4gIDwvZm9vdGVyPlxuey9pZn1cbjwvZGl2PiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDTyxTQUFTLE9BQU8sQ0FBQyxHQUFHLEVBQUU7QUFDN0IsSUFBSSxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxnQkFBZ0I7QUFDbkUsQ0FBQztBQUlNLFNBQVMsZUFBZSxHQUFHO0FBQ2xDLElBQUksTUFBTSxTQUFTLEdBQUcscUJBQXFCLEVBQUUsQ0FBQztBQUM5QyxJQUFJLE9BQU8sSUFBSSxJQUFJO0FBQ25CLE1BQU0sTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3pELE1BQU0sTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDO0FBQzNCO0FBQ0EsTUFBTSxNQUFNLENBQUMsT0FBTztBQUNwQixVQUFVLEtBQUssSUFBSSxTQUFTLENBQUMsSUFBSTtBQUNqQyxjQUFjLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsS0FBSyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzdELGFBQWE7QUFDYixTQUFTLENBQUM7QUFDVjtBQUNBLE1BQU0sT0FBTztBQUNiLFFBQVEsT0FBTyxFQUFFLE1BQU07QUFDdkIsWUFBWSxTQUFTLENBQUMsT0FBTztBQUM3QixnQkFBZ0IsUUFBUSxJQUFJLFFBQVEsRUFBRTtBQUN0QyxhQUFhLENBQUM7QUFDZCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUssQ0FBQztBQUNOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkN0QkssR0FBTyxJQUFDLE1BQU07NkJBS2QsR0FBTyxJQUFDLEtBQUs7Ozs2QkFNYixHQUFPLElBQUMsTUFBTTttQ0FaZ0IsR0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkFBN0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21CQUNiLEdBQU8sSUFBQyxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQkFLZCxHQUFPLElBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUJBTWIsR0FBTyxJQUFDLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhHQVpnQixHQUFXOzZCQUE3QixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FIUixNQUFNLEdBQUcsZUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
